#!/usr/bin/python
#
# vim: filetype=python
# ===========================================================================
# Tool "imagecompare": compare images to find out similar images.
# ---------------------------------------------------------------------------
# Working principle:
#   Compare b/w thumbs of the images, where the thumbs of all images have a
#   fixesd size.
#
# Copyright: Oliver Bandel
# Copyleft:  GNU GPL v3 or higher/later version
#
# Use this software at your own risk.
# ===========================================================================

"""
    This tool aims to find out similar or equal image-files.
    The basic idea has two parts:
        1) reducing the data of the comparison while being accurate enough
           to ensure a working comparison
        2) comparing the files via the reduced data

    Solution to 1): comparing black-/white-thumbnails of the images,
    scaled down to a fixed rectangle shape.

    Solution to 2): calculate the pixel-difference of the images, and take the
    average of the absolute value of that difference, and compare that value
    with a threshold.
    $ coeff = \frac{1}{n}\sum_{i=1}^n | x_i - y_i | $
    Thresholds:    1.5 for very similar / nearly equal images
                  10.0 for similar files

    Very similar images will be printed into a file that can be
    called as shell-script, which then calls the image-viewer 'qiv' in
    fullscreen-mode.

    All files that are found to be similar are printed in one row.
    So, for each chain of similar files, the image viewer will be
    invoked once.

    ?Similar files are also printed into that file, but with a shell-comment
    ?symbol '#' before the command, so that these commands will not be executed,
    ?if the comment-symbol is not removed before calling that file (use your
    ?favourite text editor to remove the comment symbol).

    Then deleting those files that can/should be deleted is done 'by hand',
    which means: the decision is not taken over by the software.
    The reason is: the interest which image to delete (or not delete any at all)
    can be different and depending on user and situation.
    For example:
      - don't delete any of the similar files (e.g. just view the images)
      - delete the thumbs and store the original images
      - delete the bigger images and save the (big enough) smaller one / thumbs
      - delete the similar image without some overlayed text (text annyoing)
      - delete the similar image with some overlayed text (text informative)
      - (...)
    So the decision is up to the user.

    The image viewer qiv does not remove the files immediately.
    The will be moved to the directory ./.qiv-trash and can be recovered
    this way.
"""
 
import sys
import os.path as path

from time import perf_counter as pc

from PIL import Image
import numpy as np


# Settings, hardcoded (possible candidates for settings via cli parameters)
# -------------------------------------------------------------------------
outfilename = "view-results.bash" # hardcode value: filename
thumbmatch_epsilon = 1.5 # hardcoded value: thumbmatch_epsilon (max. dist. for similarity)


#############
# FUNCTIONS #
#############

def fixedshapebwthumb(filename):
    """
    Creates one-dimensional array of the b/w image data of image-file.
    Fixed shape is 100x100.
    """
    img = Image.open(filename)

    thumb = img.resize([100,100], Image.LANCZOS) # hardcode value: fixed thumb-size
    bwthumb = thumb.convert('L')

    data = np.array(bwthumb.getdata())

    img.close()

    return data


def calc_imagediffcoeff( bwimg_1, bwimg_2 ):
    """
    The arguments bwimg_1 and bwimg_2 are numpy-arrays,
    repesenting the black-white/grayscale-images and must have the
    same dimensions (same shape).
    $ coeff = \frac{1}{n}\sum_{i=1}^n | x_i - y_i | $
    """
    absdiff = abs(bwimg_1 - bwimg_2)
    return sum(absdiff)/len(absdiff)


def print_dot():
    print(".", end='', flush = True)

def print_val_if_modulo(value, modulo, prepend):
    if not value % modulo:
        print("{} {}".format(prepend, value))



#############
# CLASSES   #
#############

class ImageThumb:
    """
    For each image (given by 'filename') this class creates an object,
    which contains the black/white thumbnail of that image.
    The image data is stored in a numpy-vector (1-dim array) of length
    n := thumbwidth * thumbheight.
    Also a distance method is available, which calculates the distance
    between two such thumbs.
    The used distance function is
      $ \frac{1}{n}\sum_{i=1}^n | x_i - y_i | $.
    """
    def __init__(self, filename):
        self.filename = filename
        self.bwthumb = fixedshapebwthumb(filename)

    def __repr__(self):
        return """ImageThumb("{}")""".format(self.filename)

    def __sub__(self, this, other):
        return self.bwthumb - other.bwthumb

    def dist(this, that):
        """
        Metric function to calculate the distance value.

        Calculation: $ \frac{1}{n}\sum_{i=1}^n | x_i - y_i | $.
        This is sum-metrics divided by n, to get a handy value.
        As Numpy does elementwise operations, no loop is needed for the
        substraction.

        Parameters: 'this' and 'that' are ImageThumb objects.
        Result:     distance between 'this' and 'that' returned.
        """
        diffval = np.sum(np.abs(this.bwthumb - that.bwthumb)) / len(this.bwthumb)
        return diffval



class DistanceChain:
    """
    Class DistanceChain to collect those thumbs, which have a distance of
    epsilon or less.
    The thumbs not necessarily line up in a chain, rather they do line up
    in a web. But the key point is, that if they would line up in a chain,
    then the max. distance between two of the n thumbs inside the chain
    would not be farther away than n * epsilon.
    This follows from the triangle inequality for n points/objects/thumbs.
    So only thumbs that have a lower distance than n * epsilon will be checked
    at all on a possible membership.
    Practically this means: for thumbs far away (farther away than n * epslion)
    only (number_of_elements_in_the_chain - 1) comparisons are needed.
    One comparison with the representant of the chain is needed anyway.
    This also means: the more images can be collected together in a
    DistanceChain, the faster this kind of comparison will be.
    """
    def __init__(self, epsilon):
        self.representant = None
        self.chainset   = set()
        self.epsilon    = epsilon


    def insert(self, candidate):
        # if chain is empty, insert first candidate as representant
        if len(self.chainset) == 0:
            self.representant = candidate
            self.chainset.add(self.representant)
            return True

        # if 'candidate' thumb is too far away, don't incorporate it
        if ImageThumb.dist(self.representant, candidate) >  self.epsilon * len(self.chainset):
            return False

        # incorporate candidate if it is in the near of one of the chain members
        for ce in self.chainset:
            if ImageThumb.dist(ce, candidate) <= self.epsilon:
                self.chainset.add(candidate)
                return True

        return False # candidate not incorporated


    def card(self):
        """cardinality of the distance chain"""
        return len(self.chainset)

    def getrepr(self):
        """the representant of the distance chain"""
        return self.representant

    def getchain(self):
        """get whole chain - returns set of the elements"""
        return self.chainset | set(self.representant)

    def print(self, outchannel=sys.stdout, viewerstring="qiv -f"):
        """print the chain: print all element-thumbs' filenames"""
        res = ""
        for thumb in self.chainset:
            res = res + ' ' +  thumb.filename
        res = viewerstring + " " + res
        print(res, file=outchannel)



def get_chainsets_from_thumblist(thumblist, epsilon):
    """
    Creation of a list of chainsets from the list of thumbs.
    Either a thumb is incoroprated into an existing chain,
    or a new chain for it will be created.
    """
    chainset = []
    for thumb in thumblist:

        # no chain existing so far?
        # then create one, append it to the list and pick new thumb
        if len(chainset) == 0:
            dc = DistanceChain(epsilon)
            dc.insert(thumb)
            chainset.append(dc)
            continue

        # try to insert thumb into any existing distance chain.
        # if successful, check next thumb.
        # if not, create new chainset for that thumb and append it to the list.
        inserted = False
        for idx, chain in enumerate(chainset):
            inserted = False
            if chain.insert(thumb):
                inserted = True
                break

        # create new distance chain for the thumb and append chain to chainlist
        if not inserted:
            dc = DistanceChain(epsilon)
            dc.insert(thumb)
            chainset.append(dc)
            continue

    return chainset


# =============================================================================
# =============================================================================
# =============================================================================

if __name__ == '__main__':

    t0 = pc() # starting timer value

    # check if filenames were given at all. Ifnot: message and exit
    if len(sys.argv) < 2:
        print("filenames as arguments needed!")
        exit(1)

    files_argv = sys.argv[1:] # filenames from command line

    print("# {} filenames given on command line.".format(len(files_argv)), file=sys.stderr, flush=True)

    outfile = open(outfilename, "w")

    # Now read the image-files and store the b/w-data of the their thumbnails
    # -----------------------------------------------------------------------
    print("# Reading in files.", file=sys.stderr, flush=True)
    print("# Reading in files.", file=outfile, flush=True)

    thumblist = []
    idx = 0
    for fileidx, fn in enumerate(files_argv):
        print_dot()
        print_val_if_modulo(idx + 1, 100, "Read file number")
        try:
            if path.islink(fn):
                print("\nignoring symbolic link \"{}\" ({}. file from command line)".format(fn, fileidx + 1), file=sys.stderr, flush=True)
                continue

            if path.isdir(fn):
                print("\nignoring dir \"{}\" ({}. file from command line)".format(fn, fileidx + 1), file=sys.stderr, flush=True)
                continue

            thumblist.append(ImageThumb(fn))

            idx = idx + 1 # index of sucessfully openbed image files

        except KeyboardInterrupt:
            print("\nCtrl-C was issued. Exiting.")
            exit(1)

        except:
            print("\nignoring file \"{}\" ({}. file from command line, could not be opened as image.)".format(fn, fileidx + 1), file=sys.stderr, flush=True)

    t1 = pc() # timer value after reading the files and creating the bw-imagedata of the thumbs

    print("\n{} images could be opened and will now be compared.".format(len(thumblist)))


    # Now do the calculations (similarity search)
    # -------------------------------------------
    print("# {} images could be opened and will now be compared.".format(len(thumblist)), file=outfile, flush=True)
    print("Please be patient, it may take a while.")
    t2 = pc() # timer
    chainset = get_chainsets_from_thumblist(thumblist, thumbmatch_epsilon)
    t3 = pc() # timer

    # print out the resulting chains
    for idx, chain in enumerate(chainset):
        if chain.card() > 1:
            chain.print(outfile)

    t4 = pc() # timer value after writing the results to the outfile

    print("# Reading images:   {:8.3f}".format(t1 - t0), file=outfile)
    print("# Calculating:      {:8.3f}".format(t3 - t2), file=outfile)
    print("# Output to file    {:8.3f}".format(t4 - t3), file=outfile)
    print("#", file=outfile)
    print("# TOTAL TIME        {:8.3f}".format(t4 - t0), file=outfile)

    outfile.close()
    print("Result has been written to \"{}\"".format(outfilename))
