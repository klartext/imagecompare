#!/usr/bin/python
#
# vim: filetype=python
# ===========================================================================
# Tool "imagecompare": compare images to find out similar images.
# ---------------------------------------------------------------------------
# Working principle:
#   Compare b/w thumbs of the images, where the thumbs of all images have a
#   fixesd size.
#
# Copyright: Oliver Bandel
# Copyleft:  GNU GPL v3 or higher/later version
#
# Use this software at your own risk.
# ===========================================================================

"""
    This tool aims to find out similar or equal image-files.
    The basic idea has two parts:
        1) reducing the data of the comparison while being accurate enough
           to ensure a working comparison
        2) comparing the files via the reduced data

    Solution to 1): comparing black-/white-thumbnails of the images,
    scaled down to a fixed rectangle shape.

    Solution to 2): calculate the pixel-difference of the images, and take the
    average of the absolute value of that difference, and compare that value
    with a threshold.
    $ coeff = \frac{1}{n}\sum_{i=1}^n | x_i - y_i | $
    Thresholds:    1.5 for very similar / nearly equal images
                  10.0 for similar files

    Very similar images will be printed into a file that can be
    called as shell-script, which then calls the image-viewer 'qiv' in
    fullscreen-mode.

    All files that are found to be similar are printed in one row.
    So, for each chain of similar files, the image viewer will be
    invoked once.

    ?Similar files are also printed into that file, but with a shell-comment
    ?symbol '#' before the command, so that these commands will not be executed,
    ?if the comment-symbol is not removed before calling that file (use your
    ?favourite text editor to remove the comment symbol).

    Then deleting those files that can/should be deleted is done 'by hand',
    which means: the decision is not taken over by the software.
    The reason is: the interest which image to delete (or not delete any at all)
    can be different and depending on user and situation.
    For example:
      - don't delete any of the similar files (e.g. just view the images)
      - delete the thumbs and store the original images
      - delete the bigger images and save the (big enough) smaller one / thumbs
      - delete the similar image without some overlayed text (text annyoing)
      - delete the similar image with some overlayed text (text informative)
      - (...)
    So the decision is up to the user.

    The image viewer qiv does not remove the files immediately.
    The will be moved to the directory ./.qiv-trash and can be recovered
    this way.
"""
 
import sys
import os.path as path

from time import perf_counter as pc

from PIL import Image
import numpy as np


# Settings, hardcoded
# -------------------
outfilename = "view-results.bash" # hardcode value: filename


#############
# FUNCTIONS #
#############

def fixedscalebwthumb(filename):
    """
    Creates onedim. array of the b/w image data of image-file.
    """
    img = Image.open(filename)

    thumb = img.resize([100,100], Image.LANCZOS) # hardcode value: fixed thumb-size
    bwthumb = thumb.convert('L')

    data = np.array(bwthumb.getdata())

    img.close()

    return data


def calc_imagediffcoeff( bwimg_1, bwimg_2 ):
    """
    The arguments bwimg_1 and bwimg_2 are numpy-arrays,
    repesenting the black-white/grayscale-images and must have the
    same dimensions (same shape).
    $ coeff = \frac{1}{n}\sum_{i=1}^n | x_i - y_i | $
    """
    absdiff = abs(bwimg_1 - bwimg_2)
    return sum(absdiff)/len(absdiff)


def print_dot():
    print(".", end='', flush = True)

def print_val_if_modulo(value, modulo, prepend):
    if not value % modulo:
        print("{} {}".format(prepend, value))




class ImageThumb:
    def __init__(self, filename):
        self.filename = filename
        self.bwthumb = fixedscalebwthumb(filename)

    def __repr__(self):
        return """ImageThumb("{}")""".format(self.filename)

    def __sub__(self, this, other):
        return self.bwthumb - other.bwthumb

    def dist(this, that):
        """
        metric function (distance value)
        """
        diffval = np.sum(np.abs(this.bwthumb - that.bwthumb)) / len(this.bwthumb)
        return diffval



class DistanceChain:
    def __init__(self, epsilon):
        self.representant = None
        self.chainset   = set()
        self.epsilon    = epsilon


    def insert(self, elem):
        #print(" METHOD: DistanceChain.insert()")
        # if chain empty, insert first element
        if len(self.chainset) == 0:
            self.representant = elem
            self.chainset.add(self.representant)
            return True

        if ImageThumb.dist(self.representant, elem) >  self.epsilon * len(self.chainset):
            return False

        for ce in self.chainset:
            if ImageThumb.dist(ce, elem) <= self.epsilon:
                self.chainset.add(elem)
                return True

        return False


    def card(self):
        return len(self.chainset)

    def getrepr(self):
        return self.representant


    def getchain(self):
        return self.chainset | set(self.representant)

    def print(self, outchannel=sys.stdout, viewerstring="qiv -f"):
        res = ""
        for thumb in self.chainset:
            res = res + ' ' +  thumb.filename
        res = viewerstring + " " + res
        print(res, file=outchannel)



def get_chainsets_from_thumblist(thumblist, epsilon):
    chainset = []
    for thumb in thumblist:

        # no chain so far? then create one, append it to the list and pick new elem
        if len(chainset) == 0:
            dc = DistanceChain(epsilon)
            dc.insert(thumb)
            chainset.append(dc)
            continue

        inserted = False
        for idx, chain in enumerate(chainset):
            inserted = False
            if chain.insert(thumb):
                inserted = True
                break

        if not inserted:
            dc = DistanceChain(epsilon)
            dc.insert(thumb)
            chainset.append(dc)
            continue

    return chainset


# =============================================================================
# =============================================================================
# =============================================================================

if __name__ == '__main__':

    t0 = pc() # starting timer value

    # check if filenames were given at all. Ifnot: message and exit
    if len(sys.argv) < 2:
        print("filenames as arguments needed!")
        exit(1)

    files_argv = sys.argv[1:]
    files = {} # list of accepted files

    print("# {} filenames given on command line.".format(len(files_argv)), file=sys.stderr, flush=True)

    outfile = open(outfilename, "w")

    # Now read the image-files and store the b/w-data of the their thumbnails
    # -----------------------------------------------------------------------
    print("# Reading in files.", file=sys.stderr, flush=True)
    print("# Reading in files.", file=outfile, flush=True)

    thumblist = []
    idx = 0
    for fileidx, fn in enumerate(files_argv):
        print_dot()
        print_val_if_modulo(idx + 1, 100, "Read file number")
        try:
            if path.islink(fn):
                print("\nignoring symbolic link \"{}\" ({}. file from command line)".format(fn, fileidx + 1), file=sys.stderr, flush=True)
                continue

            if path.isdir(fn):
                print("\nignoring dir \"{}\" ({}. file from command line)".format(fn, fileidx + 1), file=sys.stderr, flush=True)
                continue

            thumblist.append(ImageThumb(fn))

            idx = idx + 1 # index of sucessfully openbed image files

        except KeyboardInterrupt:
            print("\nCtrl-C was issued. Exiting.")
            exit(1)

        except:
            print("\nignoring file \"{}\" ({}. file from command line, could not be opened as image.)".format(fn, fileidx + 1), file=sys.stderr, flush=True)

    print("") # to have a newline after the dots.

    t1 = pc() # timer value after reading the files and creating the bw-imagedata of the thumbs

    print("{} images could be opened and will now be compared.".format(len(thumblist)))
    print("# {} images could be opened and will now be compared.".format(len(thumblist)), file=outfile, flush=True)
    print("Please be patient, it may take a while.")
    t2 = pc() # timer
    chainset = get_chainsets_from_thumblist(thumblist, 1.5) # epsilon = 1.5 # hard-coded!!!
    t3 = pc() # timer

    # print out the resulting chains
    for idx, chain in enumerate(chainset):
        if chain.card() > 1:
            chain.print(outfile)

    t4 = pc() # timer value after writing the results to the outfile

    print("# Reading images:   {:8.3f}".format(t1 - t0), file=outfile)
    print("# Calculating:      {:8.3f}".format(t3 - t2), file=outfile)
    print("# Output to file    {:8.3f}".format(t4 - t3), file=outfile)
    print("#", file=outfile)
    print("# TOTAL TIME        {:8.3f}".format(t4 - t0), file=outfile)

    outfile.close()
    print("Result has been written to \"{}\"".format(outfilename))
